---
title: "Dale_Help"
output: html_document
---



```{r}
library(dplyr)
library(tidyr)
library(mgcv)
library(ggplot2)
library(moments)
library(readr)
library(gamlss)
library(zoo)

######
#Robs code
######
setwd("/Users/dalemoskoff/Desktop")
dat<-read.csv("LythrumDisplay2008.csv")

Days<-names(dat)[grep("d[0-9]",names(dat))] # Vector of names

Flwr<-dat %>% gather(all_of(Days),key="RelDay",value="OpFlwr") # Rearrange

Flwr$RelDay<-as.numeric(gsub("d","",Flwr$RelDay)) # Remove 'd' from day

Flwr$AbsDay<-Flwr$RelDay+Flwr$Start # Add absolute day
Flwr$CumFlwr<-ave(Flwr$OpFlwr,Flwr$Num,FUN=cumsum) # Calculate cumulative N flowers

```

```{r}
####
#GAM troubleshooting
####

Individual_ID<-unique(Flwr$Num) 

#Removing number 154 from the ID list 
Individual_ID<-Individual_ID[Individual_ID!=187]

#Removing number 440 from the ID list 
Individual_ID<-Individual_ID[Individual_ID!=440]

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterData<-matrix(nrow=0,ncol=4)
colnames(MasterData)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID)) {
  Focal<-subset(Flwr,Flwr$Num==Individual_ID[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
 End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
}
  Individual<-c(rep(Individual_ID[i],length(AbsDay))) #Individual column
  NewData<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterData<-rbind(MasterData,NewData) #New data frame containing information for all individuals
  print(Individual_ID[i])
}

MasterData
```

#New code -- from after troubleshooting GAM models. 
```{r}
#GAM FUNCTION

#PredictDay<-function(Num,df){
 # Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#Linear Imputting


PredictDay<-function(Num,df){
AbsDay<-c(0:125)
PredDay<-rep(NA,length(AbsDay))
PredDay[df$AbsDay[df$Individual==Num]+1]<-df$OpFlwr[df$Individual==Num] # Add observed flower counts to predday
# is.na(PredDay) # We have to remove NAs at the beginning and end of the observed OpFlwr values to get proper LI inputs. 
if(is.na(PredDay[1])){
  PredDay[1]<-0
}
if(is.na(PredDay[length(PredDay)])){
  PredDay[length(PredDay)]<-0
}
PredDay<-na.approx(PredDay,na.rm=F)
PredDay[is.na(PredDay)]<-0
return(PredDay)
}

```

```{r}

df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
Individual_ID<-unique(MasterData$Individual)
Days<-c()
Individual<-c()
Flowers<-c()
count=0
for( j in 1:length(Individual_ID)){
    count=count+1
  FocalFrame<-MasterData[MasterData$Individual==Individual_ID[j],]
  Flowers<-PredictDay(Num=Individual_ID[j],df=MasterData)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count #Now the loop worked and you have 386 individual growth rates in total (2 did not have enough data and were removed).
#Setting the value of Flowers to 0 where GAM was predicting past observed days of flowering.
dfset0<-df3
#dfset0$Flowers[dfset0$Added0=="yes"]<-0

####
#Different Data Formats and Visualization 
####

#To convert the data to wide format, the original code we tried now works (after converting the flower data)
dfset0<-dplyr :: select(dfset0,-(Individual.y:Added0),-OpFlwr) #Remove unnecessary columns.
Mating.Matrix.Data_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data_Wide<-dplyr :: select(Mating.Matrix.Data_Wide,-(Individual.x))  #Remove individual column.


##Modelling for poster##
library(gridExtra)
Gam<-ggplot(dfset0[dfset0$Individual.x=="482",])+
  geom_line(aes(x=Days,y=Flowers,colour="red")) +
  theme_classic() + ylab("Open Flowers") + ggtitle("Linear Imputation Model") + theme(legend.position="none")  #google colour brewer 
Raw<-ggplot(MasterData[MasterData$Individual=="482",]) +
  geom_point(aes(x=AbsDay,y=OpFlwr)) + xlab("Days") + ylab("Open Flowers") + ggtitle("Raw Data")+
  theme_classic() 

grid.arrange(Raw,Gam,ncol=1,nrow=2)


### Basic modelling ###
ggplot(dfset0[dfset0$Individual.x=="9",])+
  geom_line(aes(x=Days,y=Flowers,colour=as.factor(Individual.x)))+
  theme_classic() + scale_color_brewer(palette="Set1") #google colour brewer 
MasterData
ggplot(MasterData[MasterData$Individual=="9",])+
  geom_point(aes(x=AbsDay,y=OpFlwr))+
  theme_classic() 
```

```{r}
##Convert data table to matrix
flr.matrix<-as.matrix(Mating.Matrix.Data_Wide)
#Initiate output files
rowcount<-Mating.Matrix.Data_Wide[,1]
N<-length(rowcount)
index<-1:N
output.table.rho2 <-table("NA", nrow=1, ncol=N)
output.table.path2 <- table("NA",nrow=1, ncol=N)	
output.table.pheno2 <- table("NA",nrow=1, ncol=N)

#Mother/Father matrices
mother.flr.matrix<- flr.matrix/sum(flr.matrix)
father.colsum<- apply(flr.matrix, 2,  sum)
father.flr.matrix<- apply(flr.matrix, 1, function(d) d/father.colsum) ##This is giving all NaN output.
father.flr.matrix[is.nan(father.flr.matrix)]<-0
father.flr.matrix[is.infinite(father.flr.matrix)]<-0
mating.matrix <- mother.flr.matrix %*% father.flr.matrix #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix<- sum(mating.matrix) #should be 1
```

```{r}
#Trait matrix and finding Rho for each trait

#Mom<-for( j in 1:length(Individual_ID)){
    #count=count+1
  #Kurtosis<-append(Kurtosis,kurtosis(PredictDay(Num=Individual_ID[j])))
  #Skewness<-append(Skewness,skewness(PredictDay(Num=Individual_ID[j])))
  #Variance<-append(Variance,var(PredictDay(Num=Individual_ID[j])))
#} 
#Focal<-df3[df3$Individual.x==Individual_ID[10],]
#  pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE)
#  WeightDays<-Focal$Days*pDays
# Mean<-sum(WeightDays,na.rm=TRUE)
#  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
#  CoeffVar<-Var/(Mean)
#  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
#  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
#  Kurtosis<-append(Kurtosis,CoeffKurt)
#  Skewness<-append(Skewness,CoeffSkew)
#  Variance<-append(Variance,CoeffVar)
  #Focal$Days[max(Focal$OpFlwr,na.rm=TRUE)]
  #max(Focal$OpFlwr,na.rm=TRUE)


#Find moments.
Kurtosis<-c()
Skewness<-c()
Variance<-c()
Start.date<-c()
End.date<-c()
Duration<-c()
Peak<-c()
##New moments for-loop with new dataset. 
Mom<-for( j in 1:length(Individual_ID)){
    count=count+1
  Focal<-df3[df3$Individual.x==Individual_ID[j],]
  pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE)
  WeightDays<-Focal$Days*pDays
  Mean<-sum(WeightDays,na.rm=TRUE)
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis<-append(Kurtosis,CoeffKurt)
  Skewness<-append(Skewness,CoeffSkew)
  Variance<-append(Variance,CoeffVar)
  Start.date<-append(Start.date,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date<-append(End.date,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis[is.nan(Kurtosis)]<-0
Skewness[is.nan(Skewness)]<-0
Variance[is.nan(Variance)]<-0

```

```{r}

##Find probabilities of each moment.
#KurtosisProb<-Kurtosis/sum(Kurtosis)
#SkewnessProb<-Skewness/sum(Skewness)
#VarianceProb<-Variance/sum(Variance)

##Find mean variance
mean(Variance)


###Find start date 
#Start.date<-as.numeric(names(Mating.Matrix.Data_Wide)[apply(Mating.Matrix.Data_Wide != 0, 1, which.max)]) # LI models

###Find end date
#End.date<-as.numeric(names(Mating.Matrix.Data_Wide)[max.col(Mating.Matrix.Data_Wide != 0, 'last')]) # LI models



###Find duration
Duration<-End.date-Start.date


##Convert to z vector 
Kurt.norm<-as.vector(scale(Kurtosis))
Skew.norm<-as.vector(scale(Skewness))
Var.norm<-as.vector(scale(Variance))
Start.date.norm<-as.vector(scale(Start.date))
Duration.norm<-as.vector(scale(Duration))


#Trait matrix -- Kurtosis
trait.matrix.k<-as.matrix(Kurt.norm) 
#Rho  -- Kurtosis
rho.matrix.k <- t(trait.matrix.k) %*% mating.matrix %*% trait.matrix.k 
rho.matrix.k

#Trait matrix -- Skewness
trait.matrix.s<-as.matrix(Skew.norm)
#Rho -- Skewness
rho.matrix.s <- t(trait.matrix.s) %*% mating.matrix %*% trait.matrix.s
rho.matrix.s


#Trait matrix -- Variance
trait.matrix.v<-as.matrix(Var.norm) 
#Rho -- Variance
rho.matrix.v <- t(trait.matrix.v) %*% mating.matrix %*% trait.matrix.v
rho.matrix.v  ##Value greater than 1-- decided not to use in my results.

#Trait matrix -- Start date
trait.matrix.st<-as.matrix(Start.date.norm) 
#Rho -- Start date
rho.matrix.st <- t(trait.matrix.st) %*% mating.matrix %*% trait.matrix.st
rho.matrix.st

#Trait matrix -- Duration
trait.matrix.d<-as.matrix(Duration.norm)
#Rho -- Duration
rho.matrix.d <- t(trait.matrix.d) %*% mating.matrix %*% trait.matrix.d
rho.matrix.d

#Trait matrix -- PC1
trait.matrix.PC1<-as.matrix(PC1)
#Rho -- PC1
rho.matrix.PC1 <- t(trait.matrix.PC1) %*% mating.matrix %*% trait.matrix.PC1
rho.matrix.PC1
```

```{r}
###List of PC1 ####
length(Individual_ID)
PC1<-Flwr %>% group_by(Num) %>% dplyr :: select(Num,PC1) %>% summarise(PC1=mean(PC1,na.rm=TRUE))
PC1$PC1[is.nan(PC1$PC1)]<-0 
grep(440,PC1$Num) #347
grep(187,PC1$Num) #154
PC1<-PC1[-c(154,347),]
PC1<-dplyr :: select(PC1,-(Num))


average.PC1<-mean(PC1$PC1)
average.PC1 #Entire sample PC1 mean.

##Vectors of PC1 by population
PC1.by.population<-Flwr %>% group_by(Pop) %>% dplyr :: select(Pop,PC1)
PC1.by.population<-Flwr %>% group_by(Num) %>% dplyr :: select(Num,Pop,PC1) %>% summarise(PC1=mean(PC1,na.rm=TRUE))

PC1.by.population$PC1[is.na(PC1.by.population$PC1)]<-0 

##Average PC1 by population code.##
PC1.mean.by.population<-Flwr %>% group_by(Pop) %>% dplyr :: select(Pop,PC1) %>% summarise(PC1=mean(PC1,na.rm=TRUE))
PC1.mean.by.population
write.csv(PC1.by.population,"PC1 means by population.csv")

```

```{r}
##Principal component analysis for S
prcomp(mating.matrix,scale=FALSE)
X<-eigen(mating.matrix,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for the entire dataset
Y<-X$values
S<-Y[1]/sum(Y)
S
```
#New Code ONEC
```{r}
##ONEC Population

##Create table of GAM predicted # of open flowers/day/individual for just ONEC population
ONEC<-subset(Flwr,Flwr$Pop=="ONEC")
Individual_ID2<-unique(ONEC$Num) 

#Create MasterData
MasterDataONEC<-matrix(nrow=0,ncol=4)
colnames(MasterDataONEC)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID2)) {
  Focal<-subset(ONEC,ONEC$Num==Individual_ID2[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep NA for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep NA for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep NA
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID2[i],length(AbsDay))) #Individual column
  NewDataONEC<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONEC<-rbind(MasterDataONEC,NewDataONEC) #New data frame containing information for all individuals
  print(Individual_ID2[i])
}

MasterDataONEC

##GAM function 
#PredictDayONEC<-function(Num,days=c(0:125),df){
 # Mod2<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
 # PredDay2<-predict(Mod2,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
 # PredDay2[PredDay2<0]<-0 #Changing negative values to zero.
#return(PredDay2)
#}

df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
Days<-c()
Individual<-c()
Flowers<-c()
count=0
for( j in 1:length(Individual_ID2)){
    count=count+1
  FocalFrame<-MasterDataONEC[MasterDataONEC$Individual==Individual_ID2[j],]
  Flowers<-PredictDay(Num=Individual_ID2[j],df=MasterDataONEC)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID2[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count 

dfset0<-df3

#To convert the data to wide format, the original code we tried now works (after converting the flower data)
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONEC_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONEC_Wide<-dplyr :: select(Mating.Matrix.Data.ONEC_Wide,-(Individual.x))  #Remove individual column.


##Mating matrix just ONEC population

flr.matrix.ONEC<-as.matrix(Mating.Matrix.Data.ONEC_Wide)
#Mother/Father matrices
mother.flr.matrix.ONEC<- flr.matrix.ONEC/sum(flr.matrix.ONEC)
father.colsum.ONEC<- apply(flr.matrix.ONEC, 2,  sum)
father.flr.matrix.ONEC<- apply(flr.matrix.ONEC, 1, function(d) d/father.colsum.ONEC) 
father.flr.matrix.ONEC[is.nan(father.flr.matrix.ONEC)]<-0
father.flr.matrix.ONEC[is.infinite(father.flr.matrix.ONEC)]<-0
mating.matrix.ONEC <- mother.flr.matrix.ONEC %*% father.flr.matrix.ONEC #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONEC<- sum(mating.matrix.ONEC) #should be 1

##Principal component analysis for S of ONEC population

prcomp(mating.matrix.ONEC,scale=FALSE)
X2<-eigen(mating.matrix.ONEC,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONEC Pop
Y2<-X2$values
S.ONEC<-Y2[1]/sum(Y2)
S.ONEC

#Trait matrix and finding Rho for each trait

#Find moments.
Kurtosis.ONEC<-c()
Skewness.ONEC<-c()
Variance.ONEC<-c()
Start.date.ONEC<-c()
End.date.ONEC<-c()
Duration.ONEC<-c()
count2=0
Mom.ONEC<-for( j in 1:length(Individual_ID2)){
    count2=count2+1
  Focal<-df3[df3$Individual.x==Individual_ID2[j],]
  pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE)
  WeightDays<-Focal$Days*pDays
  Mean<-sum(WeightDays,na.rm=TRUE)
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONEC<-append(Kurtosis.ONEC,CoeffKurt)
  Skewness.ONEC<-append(Skewness.ONEC,CoeffSkew)
  Variance.ONEC<-append(Variance.ONEC,CoeffVar)
  Start.date.ONEC<-append(Start.date.ONEC,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONEC<-append(End.date.ONEC,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONEC[is.nan(Kurtosis.ONEC)]<-0
Skewness.ONEC[is.nan(Skewness.ONEC)]<-0
Variance.ONEC[is.nan(Variance.ONEC)]<-0

#KurtosisProb.ONEC<-Kurtosis.ONEC/sum(Kurtosis.ONEC)
#SkewnessProb.ONEC<-Skewness.ONEC/sum(Skewness.ONEC)
#VarianceProb.ONEC<-Variance.ONEC/sum(Variance.ONEC)

##Find mean variance
mean(Variance.ONEC)

###Find start date  
#Start.date.ONEC<-as.numeric(names(Mating.Matrix.Data.ONEC_Wide)[apply(Mating.Matrix.Data.ONEC_Wide != 0, 1, which.max)])

###Find end date
#End.date.ONEC<-as.numeric(names(Mating.Matrix.Data.ONEC_Wide)[max.col(Mating.Matrix.Data.ONEC_Wide != 0, 'last')])


###Find duration
Duration.ONEC<-End.date.ONEC-Start.date.ONEC


##Convert to vector 
Kurt.norm.ONEC<-as.vector(scale(Kurtosis.ONEC))
Skew.norm.ONEC<-as.vector(scale(Skewness.ONEC))
Var.norm.ONEC<-as.vector(scale(Variance.ONEC))
Start.date.norm.ONEC<-as.vector(scale(Start.date.ONEC))
Duration.norm.ONEC<-as.vector(scale(Duration.ONEC))

#Trait matrix -- Kurtosis
trait.matrix.k.ONEC<-as.matrix(Kurt.norm.ONEC) 
#Rho  -- Kurtosis
rho.matrix.k.ONEC <- t(trait.matrix.k.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.k.ONEC
rho.matrix.k.ONEC 


#Trait matrix -- Skewness
trait.matrix.s.ONEC<-as.matrix(Skew.norm.ONEC)
#Rho -- Skewness
rho.matrix.s.ONEC <- t(trait.matrix.s.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.s.ONEC
rho.matrix.s.ONEC


#Trait matrix -- Variance
trait.matrix.v.ONEC<-as.matrix(Var.norm.ONEC) 
#Rho -- Variance
rho.matrix.v.ONEC <- t(trait.matrix.v.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.v.ONEC
rho.matrix.v.ONEC 


#Trait matrix -- Start date
trait.matrix.st.ONEC<-as.matrix(Start.date.norm.ONEC) 
#Rho -- Start date
rho.matrix.st.ONEC <- t(trait.matrix.st.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.st.ONEC
rho.matrix.st.ONEC

#Trait matrix -- Duration
trait.matrix.d.ONEC<-as.matrix(Duration.norm.ONEC)
#Rho -- Duration
rho.matrix.d.ONEC <- t(trait.matrix.d.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.d.ONEC
rho.matrix.d.ONEC

#Trait matrix -- PC1
trait.matrix.PC1.ONEC<-as.matrix(PC1.ONEC)
#Rho -- PC1
rho.matrix.PC1.ONEC <- t(trait.matrix.PC1.ONEC) %*% mating.matrix.ONEC %*% trait.matrix.PC1.ONEC
rho.matrix.PC1.ONEC


```


```{r}
##MDDB Population


##Create table of GAM predicted # of open flowers/day/individual for just MDDB population
MDDB<-subset(Flwr,Flwr$Pop=="MDDB")
MDDB
Individual_ID3<-unique(MDDB$Num)

#Create MasterData
MasterDataMDDB<-matrix(nrow=0,ncol=4)
colnames(MasterDataMDDB)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID3)) {
  Focal<-subset(MDDB,MDDB$Num==Individual_ID3[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID3[i],length(AbsDay))) #Individual column
  NewDataMDDB<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataMDDB<-rbind(MasterDataMDDB,NewDataMDDB) #New data frame containing information for all individuals
  print(Individual_ID3[i])
}


#PredictDay function for MDDB dataset
#PredictDayMDDB<-function(Num,days=c(0:125),df){
 # Mod3<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay3<-predict(Mod3,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
 # PredDay3[PredDay3<0]<-0 #Changing negative values to zero.
#return(PredDay3)
#}

df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
Days<-c()
Individual<-c()
Flowers<-c()
count=0
for( j in 1:length(Individual_ID3)){
    count=count+1
  FocalFrame<-MasterDataMDDB[MasterDataMDDB$Individual==Individual_ID3[j],]
  Flowers<-PredictDay(Num=Individual_ID3[j],df=MasterDataMDDB)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID3[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count #Now the loop worked and you have 386 individual growth rates in total (2 did not have enough data and were removed).
#Setting the value of Flowers to 0 where GAM was predicting past observed days of flowering.
dfset0<-df3

#To convert the data to wide format, the original code we tried now works (after converting the flower data)
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.MDDB_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.MDDB_Wide<-dplyr :: select(Mating.Matrix.Data.MDDB_Wide,-(Individual.x))  #Remove individual column.


##Mating matrix just MDDB population

flr.matrix.MDDB<-as.matrix(Mating.Matrix.Data.MDDB_Wide)
#Mother/Father matrices
mother.flr.matrix.MDDB<- flr.matrix.MDDB/sum(flr.matrix.MDDB)
father.colsum.MDDB<- apply(flr.matrix.MDDB, 2,  sum)
father.flr.matrix.MDDB<- apply(flr.matrix.MDDB, 1, function(d) d/father.colsum.MDDB)
father.flr.matrix.MDDB[is.nan(father.flr.matrix.MDDB)]<-0
father.flr.matrix.MDDB[is.infinite(father.flr.matrix.MDDB)]<-0
mating.matrix.MDDB <- mother.flr.matrix.MDDB %*% father.flr.matrix.MDDB #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.MDDB<- sum(mating.matrix.MDDB) #should be 1


##Principal component analysis for S of MDDB population

prcomp(mating.matrix.MDDB,scale=FALSE)
X3<-eigen(mating.matrix.MDDB,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for MDDB
Y3<-X3$values
S.MDDB<-Y3[1]/sum(Y3)
S.MDDB



###Trait matrix and finding Rho for each trait MDDB
#Find moments.
Kurtosis.MDDB<-c()
Skewness.MDDB<-c()
Variance.MDDB<-c()
Start.date.MDDB<-c()
End.date.MDDB<-c()
Duration.MDDB<-c()
PC1.MDDB<-c()
count3=0
Mom.MDDB<-for( j in 1:length(Individual_ID3)){
    count3=count3+1
  Focal<-df3[df3$Individual.x==Individual_ID3[j],] 
  pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.MDDB<-append(Kurtosis.MDDB,CoeffKurt)
  Skewness.MDDB<-append(Skewness.MDDB,CoeffSkew)
  Variance.MDDB<-append(Variance.MDDB,CoeffVar)
  Start.date.MDDB<-append(Start.date.MDDB,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.MDDB<-append(End.date.MDDB,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.MDDB[is.nan(Kurtosis.MDDB)]<-0
Skewness.MDDB[is.nan(Skewness.MDDB)]<-0
Variance.MDDB[is.nan(Variance.MDDB)]<-0



#Find probabilities of each moment.
#KurtosisProb.MDDB<-Kurtosis.MDDB/sum(Kurtosis.MDDB)
#SkewnessProb.MDDB<-Skewness.MDDB/sum(Skewness.MDDB)
#VarianceProb.MDDB<-Variance.MDDB/sum(Variance.MDDB)

###Find average variance 
mean(Variance.MDDB)

###Find start date
#Start.date.MDDB<-as.numeric(names(Mating.Matrix.Data.MDDB_Wide)[apply(Mating.Matrix.Data.MDDB_Wide != 0, 1, which.max)])

###Find end date
#End.date.MDDB<-as.numeric(names(Mating.Matrix.Data.MDDB_Wide)[max.col(Mating.Matrix.Data.MDDB_Wide != 0, 'last')])


###Find duration
Duration.MDDB<-End.date.MDDB-Start.date.MDDB


##Get z vector 
Kurt.norm.MDDB<-as.vector(scale(Kurtosis.MDDB))
Skew.norm.MDDB<-as.vector(scale(Skewness.MDDB))
Var.norm.MDDB<-as.vector(scale(Variance.MDDB))
Start.date.norm.MDDB<-as.vector(scale(Start.date.MDDB))
Duration.norm.MDDB<-as.vector(scale(Duration.MDDB))

#Trait matrix -- Kurtosis
trait.matrix.k.MDDB<-as.matrix(Kurt.norm.MDDB) 
#Rho  -- Kurtosis
rho.matrix.k.MDDB <- t(trait.matrix.k.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.k.MDDB
rho.matrix.k.MDDB


#Trait matrix -- Skewness
trait.matrix.s.MDDB<-as.matrix(Skew.norm.MDDB)
#Rho -- Skewness
rho.matrix.s.MDDB <- t(trait.matrix.s.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.s.MDDB
rho.matrix.s.MDDB

# Trait matrix -- variance.
trait.matrix.v.MDDB<-as.matrix(Var.norm.MDDB) 
#Rho -- Variance
rho.matrix.v.MDDB <- t(trait.matrix.v.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.v.MDDB
rho.matrix.v.MDDB ##Value greater than 1.

#Trait matrix -- Start date
trait.matrix.st.MDDB<-as.matrix(Start.date.norm.MDDB) 
#Rho -- Start date
rho.matrix.st.MDDB <- t(trait.matrix.st.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.st.MDDB
rho.matrix.st.MDDB

#Trait matrix -- Duration
trait.matrix.d.MDDB<-as.matrix(Duration.norm.MDDB)
#Rho -- Duration
rho.matrix.d.MDDB <- t(trait.matrix.d.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.d.MDDB
rho.matrix.d.MDDB

#Trait matrix -- PC1
#trait.matrix.PC1.MDDB<-as.matrix(PC1.MDDB)
#Rho -- PC1
#rho.matrix.PC1.MDDB <- t(trait.matrix.PC1.MDDB) %*% mating.matrix.MDDB %*% trait.matrix.PC1.MDDB
#rho.matrix.PC1.MDDB

```

```{r}
##ONRO Population
##Create table of GAM predicted # of open flowers/day/individual for just ONRO population
ONRO<-subset(Flwr,Flwr$Pop=="ONRO")

#New code
Individual_ID4<-unique(ONRO$Num)
Individual_ID4<-Individual_ID4[Individual_ID4!=174]
Individual_ID4<-Individual_ID4[Individual_ID4!=410]
Individual_ID4<-Individual_ID4[Individual_ID4!=415]
#Individual_ID4<-c(373,296,178,75,332,265,138,235,2,23,129,135,163,239,249,279,306,319,336,343,375,412,416,482)

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONRO<-matrix(nrow=0,ncol=4)
colnames(MasterDataONRO)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID4)) {
  Focal<-subset(ONRO,ONRO$Num==Individual_ID4[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID4[i],length(AbsDay))) #Individual column
  NewDataONRO<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONRO<-rbind(MasterDataONRO,NewDataONRO) #New data frame containing information for all individuals
  print(Individual_ID4[i])
}



#PredictDayONRO<-function(Num,days=c(0:125),df){
 # Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
  #PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
  #PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
Days<-c()
Individual<-c()
Flowers<-c()
count=0
for( j in 1:length(Individual_ID4)){
    count=count+1
  FocalFrame<-MasterDataONRO[MasterDataONRO$Individual==Individual_ID4[j],]
  Flowers<-PredictDay(Num=Individual_ID4[j],df=MasterDataONRO)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID4[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count #Now the loop worked and you have 386 individual growth rates in total (2 did not have enough data and were removed).
#Setting the value of Flowers to 0 where GAM was predicting past observed days of flowering.
dfset0<-df3
#dfset0$Flowers[dfset0$Added0=="yes"]<-0

####
#Different Data Formats 
####

#To convert the data to wide format, the original code we tried now works (after converting the flower data)
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONRO_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONRO_Wide<-dplyr :: select(Mating.Matrix.Data.ONRO_Wide,-(Individual.x))  #Remove individual column.



##Rho matrices
flr.matrix.ONRO<-as.matrix(Mating.Matrix.Data.ONRO_Wide)
#Mother/Father matrices
mother.flr.matrix.ONRO<- flr.matrix.ONRO/sum(flr.matrix.ONRO)
father.colsum.ONRO<- apply(flr.matrix.ONRO, 2,  sum)
father.flr.matrix.ONRO<- apply(flr.matrix.ONRO, 1, function(d) d/father.colsum.ONRO) #don't understand this line
father.flr.matrix.ONRO[is.nan(father.flr.matrix.ONRO)]<-0
father.flr.matrix.ONRO[is.infinite(father.flr.matrix.ONRO)]<-0
mating.matrix.ONRO <- mother.flr.matrix.ONRO %*% father.flr.matrix.ONRO #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONRO<- sum(mating.matrix.ONRO) #should be 1


##Principal component analysis for S of ONRO population

#prcomp(mating.matrix.ONRO,scale=FALSE)
X4<-eigen(mating.matrix.ONRO,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONRO
Y4<-X4$values
S.ONRO<-Y4[1]/sum(Y4)
S.ONRO


##Trait matrices.
###Trait matrix and finding Rho for each trait ONRO
#Find moments.
Kurtosis.ONRO<-c()
Skewness.ONRO<-c()
Variance.ONRO<-c()
Start.date.ONRO<-c()
End.date.ONRO<-c()
Duration.ONRO<-c()
PC1.ONRO<-c()
count4=0
Mom.ONRO<-for( j in 1:length(Individual_ID4)){
    count4=count4+1
  Focal<-df3[df3$Individual.x==Individual_ID4[j],]
  pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONRO<-append(Kurtosis.ONRO,CoeffKurt)
  Skewness.ONRO<-append(Skewness.ONRO,CoeffSkew)
  Variance.ONRO<-append(Variance.ONRO,CoeffVar)
  Start.date.ONRO<-append(Start.date.ONRO,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONRO<-append(End.date.ONRO,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONRO[is.nan(Kurtosis.ONRO)]<-0
Skewness.ONRO[is.nan(Skewness.ONRO)]<-0
Variance.ONRO[is.nan(Variance.ONRO)]<-0


##Find probabilities of each moment.
#KurtosisProb.ONRO<-Kurtosis.ONRO/sum(Kurtosis.ONRO)
#SkewnessProb.ONRO<-Skewness.ONRO/sum(Skewness.ONRO)
#VarianceProb.ONRO<-Variance.ONRO/sum(Variance.ONRO)

##Find average variance.
mean(Variance.ONRO)


###Find start date 
#Start.date.ONRO<-as.numeric(names(Mating.Matrix.Data.ONRO_Wide)[apply(Mating.Matrix.Data.ONRO_Wide != 0, 1, which.max)])
#Start.date.ONRO

###Find end date
#End.date.ONRO<-as.numeric(names(Mating.Matrix.Data.ONRO_Wide)[max.col(Mating.Matrix.Data.ONRO_Wide != 0, 'last')])
#End.date.ONRO

###Find duration
Duration.ONRO<-End.date.ONRO-Start.date.ONRO
Duration.ONRO

##Get z vector 
Kurt.norm.ONRO<-as.vector(scale(Kurtosis.ONRO))
Skew.norm.ONRO<-as.vector(scale(Skewness.ONRO))
Var.norm.ONRO<-as.vector(scale(Variance.ONRO))
Start.date.norm.ONRO<-as.vector(scale(Start.date.ONRO))
Duration.norm.ONRO<-as.vector(scale(Duration.ONRO))

#Trait matrix -- Kurtosis
trait.matrix.k.ONRO<-as.matrix(Kurt.norm.ONRO) 
#Rho  -- Kurtosis
rho.matrix.k.ONRO <- t(trait.matrix.k.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.k.ONRO
rho.matrix.k.ONRO


#Trait matrix -- Skewness
trait.matrix.s.ONRO<-as.matrix(Skew.norm.ONRO)
#Rho -- Skewness
rho.matrix.s.ONRO <- t(trait.matrix.s.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.s.ONRO
rho.matrix.s.ONRO

# Trait matrix -- variance.
trait.matrix.v.ONRO<-as.matrix(Var.norm.ONRO) 
#Rho -- Variance
rho.matrix.v.ONRO <- t(trait.matrix.v.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.v.ONRO
rho.matrix.v.ONRO

## STOPPED CALCULATING VARIANCE BC DECIDED NOT TO USE IN RESULTS. 

#Trait matrix -- Start date
trait.matrix.st.ONRO<-as.matrix(Start.date.norm.ONRO) 
#Rho -- Start date
rho.matrix.st.ONRO <- t(trait.matrix.st.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.st.ONRO
rho.matrix.st.ONRO

#Trait matrix -- Duration
trait.matrix.d.ONRO<-as.matrix(Duration.norm.ONRO)
#Rho -- Duration
rho.matrix.d.ONRO <- t(trait.matrix.d.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.d.ONRO
rho.matrix.d.ONRO

#Trait matrix -- PC1
#trait.matrix.PC1.ONRO<-as.matrix(PC1.ONRO)
#Rho -- PC1
#rho.matrix.PC1.ONRO <- t(trait.matrix.PC1.ONRO) %*% mating.matrix.ONRO %*% trait.matrix.PC1.ONRO
#rho.matrix.PC1.ONRO
```


```{r}
##NYSC Population


##Create table of GAM predicted # of open flowers/day/individual for just NYSC population
NYSC<-subset(Flwr,Flwr$Pop=="NYSC")
NYSC

Individual_ID5<-unique(NYSC$Num)

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataNYSC<-matrix(nrow=0,ncol=4)
colnames(MasterDataNYSC)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID5)) {
  Focal<-subset(NYSC,NYSC$Num==Individual_ID5[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID5[i],length(AbsDay))) #Individual column
  NewDataNYSC<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataNYSC<-rbind(MasterDataNYSC,NewDataNYSC) #New data frame containing information for all individuals
  print(Individual_ID5[i])
}


#PredictDay function for NYSC dataset
#PredictDayNYSC<-function(Num,days=c(0:125),df){
 # Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
Days<-c()
Individual<-c()
Flowers<-c()
count5=0
for( j in 1:length(Individual_ID5)){
    count5=count5+1
  FocalFrame<-MasterDataNYSC[MasterDataNYSC$Individual==Individual_ID5[j],]
  Flowers<-PredictDay(Num=Individual_ID5[j],df=MasterDataNYSC)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID5[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count
dfset0<-df3


####
#Different Data Formats 
####

#To convert the data to wide format, the original code we tried now works (after converting the flower data)
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.NYSC_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.NYSC_Wide<-dplyr :: select(Mating.Matrix.Data.NYSC_Wide,-(Individual.x))  #Remove individual column.



##Mating matrix just ONEC population

flr.matrix.NYSC<-as.matrix(Mating.Matrix.Data.NYSC_Wide)
#Mother/Father matrices
mother.flr.matrix.NYSC<- flr.matrix.NYSC/sum(flr.matrix.NYSC)
father.colsum.NYSC<- apply(flr.matrix.NYSC, 2,  sum)
father.flr.matrix.NYSC<- apply(flr.matrix.NYSC, 1, function(d) d/father.colsum.NYSC) #don't understand this line
father.flr.matrix.NYSC[is.nan(father.flr.matrix.NYSC)]<-0
father.flr.matrix.NYSC[is.infinite(father.flr.matrix.NYSC)]<-0
mating.matrix.NYSC <- mother.flr.matrix.NYSC %*% father.flr.matrix.NYSC #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.NYSC<- sum(mating.matrix.NYSC) #should be 1
sum.mating.matrix.NYSC



##Principal component analysis for S of ONEC population

prcomp(mating.matrix.NYSC,scale=FALSE)
X5<-eigen(mating.matrix.NYSC,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONEC
Y5<-X5$values
S.NYSC<-Y5[1]/sum(Y5)
S.NYSC



###Trait matrix and finding Rho for each trait ONEC
#Find moments
Kurtosis.NYSC<-c()
Skewness.NYSC<-c()
Variance.NYSC<-c()
Start.date.NYSC<-c()
End.date.NYSC<-c()
Duration.NYSC<-c()
count5=0
Mom.NYSC<-for( j in 1:length(Individual_ID5)){
    count5=count5+1
  Focal<-df3[df3$Individual.x==Individual_ID5[j],]
    pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.NYSC<-append(Kurtosis.NYSC,CoeffKurt)
  Skewness.NYSC<-append(Skewness.NYSC,CoeffSkew)
  Variance.NYSC<-append(Variance.NYSC,CoeffVar)
  Start.date.NYSC<-append(Start.date.NYSC,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.NYSC<-append(End.date.NYSC,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.NYSC[is.nan(Kurtosis.NYSC)]<-0
Skewness.NYSC[is.nan(Skewness.NYSC)]<-0
Variance.NYSC[is.nan(Variance.NYSC)]<-0

#Find probabilities of each moment.
#KurtosisProb.NYSC<-Kurtosis.NYSC/sum(Kurtosis.NYSC)
#SkewnessProb.NYSC<-Skewness.NYSC/sum(Skewness.NYSC)
#VarianceProb.NYSC<-Variance.NYSC/sum(Variance.NYSC)


##Find average variance.
mean(Variance.NYSC)

###Find start date
#Start.date.NYSC<-as.numeric(names(Mating.Matrix.Data.NYSC_Wide)[apply(Mating.Matrix.Data.NYSC_Wide != 0, 1, which.max)]) ##Take out -1
#Start.date.NYSC

###Find end date
#End.date.NYSC<-as.numeric(names(Mating.Matrix.Data.NYSC_Wide)[max.col(Mating.Matrix.Data.NYSC_Wide != 0, 'last')])
#End.date.NYSC

###Find duration
Duration.NYSC<-End.date.NYSC-Start.date.NYSC

###Vector of PC1 ####


##Convert to z vector. 
Kurt.norm.NYSC<-as.vector(scale(Kurtosis.NYSC))
Skew.norm.NYSC<-as.vector(scale(Skewness.NYSC))
Var.norm.NYSC<-as.vector(scale(Variance.NYSC))
Start.date.norm.NYSC<-as.vector(scale(Start.date.NYSC))
Duration.norm.NYSC<-as.vector(scale(Duration.NYSC)) 

#Trait matrix -- Kurtosis
trait.matrix.k.NYSC<-as.matrix(Kurt.norm.NYSC) 
#Rho  -- Kurtosis
rho.matrix.k.NYSC <- t(trait.matrix.k.NYSC) %*% mating.matrix.NYSC %*% trait.matrix.k.NYSC
rho.matrix.k.NYSC


#Trait matrix -- Skewness
trait.matrix.s.NYSC<-as.matrix(Skew.norm.NYSC)
#Rho -- Skewness
rho.matrix.s.NYSC <- t(trait.matrix.s.NYSC) %*% mating.matrix.NYSC %*% trait.matrix.s.NYSC
rho.matrix.s.NYSC

# Trait matrix -- variance.
trait.matrix.v.NYSC<-as.matrix(Var.norm.NYSC) 
#Rho -- Variance
rho.matrix.v.NYSC <- t(trait.matrix.v.NYSC) %*% mating.matrix.NYSC %*% trait.matrix.v.NYSC
rho.matrix.v.NYSC

#Trait matrix -- Start date
trait.matrix.st.NYSC<-as.matrix(Start.date.norm.NYSC) 
#Rho -- Start date
rho.matrix.st.NYSC <- t(trait.matrix.st.NYSC) %*% mating.matrix.NYSC %*% trait.matrix.st.NYSC
rho.matrix.st.NYSC

#Trait matrix -- Duration
trait.matrix.d.NYSC<-as.matrix(Duration.norm.NYSC)
#Rho -- Duration
rho.matrix.d.NYSC <- t(trait.matrix.d.NYSC) %*% mating.matrix.NYSC %*% trait.matrix.d.NYSC
rho.matrix.d.NYSC


```

```{r}
##NYLV Population


##Create table of GAM predicted # of open flowers/day/individual for just NYLV population
NYLV<-subset(Flwr,Flwr$Pop=="NYLV")
NYLV
Individual_ID6<-unique(NYLV$Num) 
Individual_ID6<-Individual_ID6[Individual_ID6!=440]

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataNYLV<-matrix(nrow=0,ncol=4)
colnames(MasterDataNYLV)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID6)) {
  Focal<-subset(NYLV,NYLV$Num==Individual_ID6[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID6[i],length(AbsDay))) #Individual column
  NewDataNYLV<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataNYLV<-rbind(MasterDataNYLV,NewDataNYLV) #New data frame containing information for all individuals
  print(Individual_ID6[i])
}

#PredictDay function for NYLV dataset
#PredictDayNYLV<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}



#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count6=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID6)){
    count6=count6+1
  FocalFrame<-MasterDataNYLV[MasterDataNYLV$Individual==Individual_ID6[j],]
  Flowers<-PredictDay(Num=Individual_ID6[j],df=MasterDataNYLV)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID6[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count6
dfset0<-df3

#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.NYLV_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.NYLV_Wide<-dplyr :: select(Mating.Matrix.Data.NYLV_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just NYLV population

flr.matrix.NYLV<-as.matrix(Mating.Matrix.Data.NYLV_Wide)
#Mother/Father matrices
mother.flr.matrix.NYLV<- flr.matrix.NYLV/sum(flr.matrix.NYLV)
father.colsum.NYLV<- apply(flr.matrix.NYLV, 2,  sum)
father.flr.matrix.NYLV<- apply(flr.matrix.NYLV, 1, function(d) d/father.colsum.NYLV) #don't understand this line
father.flr.matrix.NYLV[is.nan(father.flr.matrix.NYLV)]<-0
father.flr.matrix.NYLV[is.infinite(father.flr.matrix.NYLV)]<-0
mating.matrix.NYLV <- mother.flr.matrix.NYLV %*% father.flr.matrix.NYLV #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.NYLV<- sum(mating.matrix.NYLV) #should be 1

##Principal component analysis for S of NYLV population

prcomp(mating.matrix.NYLV,scale=FALSE)
X6<-eigen(mating.matrix.NYLV,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for NYLV
Y6<-X6$values
S.NYLV<-Y6[1]/sum(Y6)
S.NYLV



###Trait matrix and finding Rho for each trait NYLV
#Find moments
Kurtosis.NYLV<-c()
Skewness.NYLV<-c()
Variance.NYLV<-c()
Start.date.NYLV<-c()
End.date.NYLV<-c()
Duration.NYLV<-c()
count6=0
Mom.NYLV<-for( j in 1:length(Individual_ID6)){
    count6=count6+1
  Focal<-df3[df3$Individual.x==Individual_ID6[j],]
      pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.NYLV<-append(Kurtosis.NYLV,CoeffKurt)
  Skewness.NYLV<-append(Skewness.NYLV,CoeffSkew)
  Variance.NYLV<-append(Variance.NYLV,CoeffVar)
  Start.date.NYLV<-append(Start.date.NYLV,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.NYLV<-append(End.date.NYLV,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.NYLV[is.nan(Kurtosis.NYLV)]<-0
Skewness.NYLV[is.nan(Skewness.NYLV)]<-0
Variance.NYLV[is.nan(Variance.NYLV)]<-0

#Find probabilities
#KurtosisProb.NYLV<-Kurtosis.NYLV/sum(Kurtosis.NYLV)
#SkewnessProb.NYLV<-Skewness.NYLV/sum(Skewness.NYLV)
#VarianceProb.NYLV<-Variance.NYLV/sum(Variance.NYLV)



##Find average variance probability.
mean(Variance.NYLV)

###Find start date
#Start.date.NYLV<-as.numeric(names(Mating.Matrix.Data.NYLV_Wide)[apply(Mating.Matrix.Data.NYLV_Wide != 0, 1, which.max)])
#Start.date.NYLV

###Find end date
#End.date.NYLV<-as.numeric(names(Mating.Matrix.Data.NYLV_Wide)[max.col(Mating.Matrix.Data.NYLV_Wide != 0, 'last')])
#End.date.NYLV

###Find duration
Duration.NYLV<-End.date.NYLV-Start.date.NYLV

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.NYLV<-as.vector(scale(Kurtosis.NYLV))
Skew.norm.NYLV<-as.vector(scale(Skewness.NYLV))
Var.norm.NYLV<-as.vector(scale(Variance.NYLV))
Start.date.norm.NYLV<-as.vector(scale(Start.date.NYLV))
Duration.norm.NYLV<-as.vector(scale(Duration.NYLV))

#Trait matrix -- Kurtosis
trait.matrix.k.NYLV<-as.matrix(Kurt.norm.NYLV) 
#Rho  -- Kurtosis
rho.matrix.k.NYLV <- t(trait.matrix.k.NYLV) %*% mating.matrix.NYLV %*% trait.matrix.k.NYLV
rho.matrix.k.NYLV


#Trait matrix -- Skewness
trait.matrix.s.NYLV<-as.matrix(Skew.norm.NYLV)
#Rho -- Skewness
rho.matrix.s.NYLV <- t(trait.matrix.s.NYLV) %*% mating.matrix.NYLV %*% trait.matrix.s.NYLV
rho.matrix.s.NYLV

# Trait matrix -- variance.
trait.matrix.v.NYLV<-as.matrix(Var.norm.NYLV) 
#Rho -- Variance
rho.matrix.v.NYLV <- t(trait.matrix.v.NYLV) %*% mating.matrix.NYLV %*% trait.matrix.v.NYLV
rho.matrix.v.NYLV 

#Trait matrix -- Start date
trait.matrix.st.NYLV<-as.matrix(Start.date.norm.NYLV) 
#Rho -- Start date
rho.matrix.st.NYLV <- t(trait.matrix.st.NYLV) %*% mating.matrix.NYLV %*% trait.matrix.st.NYLV
rho.matrix.st.NYLV

#Trait matrix -- Duration
trait.matrix.d.NYLV<-as.matrix(Duration.norm.NYLV)
#Rho -- Duration
rho.matrix.d.NYLV <- t(trait.matrix.d.NYLV) %*% mating.matrix.NYLV %*% trait.matrix.d.NYLV
rho.matrix.d.NYLV

```

```{r}
##ONDM Population


##Create table of GAM predicted # of open flowers/day/individual for just ONDM population
ONDM<-subset(Flwr,Flwr$Pop=="ONDM")
ONDM
Individual_ID7<-unique(ONDM$Num)

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONDM<-matrix(nrow=0,ncol=4)
colnames(MasterDataONDM)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID7)) {
  Focal<-subset(ONDM,ONDM$Num==Individual_ID7[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID7[i],length(AbsDay))) #Individual column
  NewDataONDM<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONDM<-rbind(MasterDataONDM,NewDataONDM) #New data frame containing information for all individuals
  print(Individual_ID7[i])
}

#PredictDay function for ONDM dataset
#PredictDayONDM<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count7=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID7)){
    count7=count7+1
  FocalFrame<-MasterDataONDM[MasterDataONDM$Individual==Individual_ID7[j],]
  Flowers<-PredictDay(Num=Individual_ID7[j],df=MasterDataONDM)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID7[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count7
dfset0<-df3

#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONDM_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONDM_Wide<-dplyr :: select(Mating.Matrix.Data.ONDM_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just ONDM population

flr.matrix.ONDM<-as.matrix(Mating.Matrix.Data.ONDM_Wide)
#Mother/Father matrices
mother.flr.matrix.ONDM<- flr.matrix.ONDM/sum(flr.matrix.ONDM)
father.colsum.ONDM<- apply(flr.matrix.ONDM, 2,  sum)
father.flr.matrix.ONDM<- apply(flr.matrix.ONDM, 1, function(d) d/father.colsum.ONDM) #don't understand this line
father.flr.matrix.ONDM[is.nan(father.flr.matrix.ONDM)]<-0
father.flr.matrix.ONDM[is.infinite(father.flr.matrix.ONDM)]<-0
mating.matrix.ONDM <- mother.flr.matrix.ONDM %*% father.flr.matrix.ONDM #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONDM<- sum(mating.matrix.ONDM) #should be 1


##Principal component analysis for S of ONDM population

prcomp(mating.matrix.ONDM,scale=FALSE)
X7<-eigen(mating.matrix.ONDM,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONDM
Y7<-X7$values
S.ONDM<-Y7[1]/sum(Y7)
S.ONDM


###Trait matrix and finding Rho for each trait ONDM
#Find moments
Kurtosis.ONDM<-c()
Skewness.ONDM<-c()
Variance.ONDM<-c()
Start.date.ONDM<-c()
End.date.ONDM<-c()
Duration.ONDM<-c()
count7=0
Mom.ONDM<-for( j in 1:length(Individual_ID7)){
    count7=count7+1
  Focal<-df3[df3$Individual.x==Individual_ID7[j],]
      pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONDM<-append(Kurtosis.ONDM,CoeffKurt)
  Skewness.ONDM<-append(Skewness.ONDM,CoeffSkew)
  Variance.ONDM<-append(Variance.ONDM,CoeffVar)
  Start.date.ONDM<-append(Start.date.ONDM,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONDM<-append(End.date.ONDM,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONDM[is.nan(Kurtosis.ONDM)]<-0
Skewness.ONDM[is.nan(Skewness.ONDM)]<-0
Variance.ONDM[is.nan(Variance.ONDM)]<-0

#Find probabilities of each moment.
#KurtosisProb.ONDM<-Kurtosis.ONDM/sum(Kurtosis.ONDM)
#SkewnessProb.ONDM<-Skewness.ONDM/sum(Skewness.ONDM)
#VarianceProb.ONDM<-Variance.ONDM/sum(Variance.ONDM)

##Find average variance.
mean(Variance.ONDM)

###Find start date
#Start.date.ONDM<-as.numeric(names(Mating.Matrix.Data.ONDM_Wide)[apply(Mating.Matrix.Data.ONDM_Wide != 0, 1, which.max)])
#Start.date.ONDM

###Find end date
#End.date.ONDM<-as.numeric(names(Mating.Matrix.Data.ONDM_Wide)[max.col(Mating.Matrix.Data.ONDM_Wide != 0, 'last')])
#End.date.ONDM

###Find duration
Duration.ONDM<-End.date.ONDM-Start.date.ONDM

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.ONDM<-as.vector(scale(Kurtosis.ONDM))
Skew.norm.ONDM<-as.vector(scale(Skewness.ONDM))
Var.norm.ONDM<-as.vector(scale(Variance.ONDM))
Start.date.norm.ONDM<-as.vector(scale(Start.date.ONDM))
Duration.norm.ONDM<-as.vector(scale(Duration.ONDM))

#Trait matrix -- Kurtosis
trait.matrix.k.ONDM<-as.matrix(Kurt.norm.ONDM) 
#Rho  -- Kurtosis
rho.matrix.k.ONDM <- t(trait.matrix.k.ONDM) %*% mating.matrix.ONDM %*% trait.matrix.k.ONDM
rho.matrix.k.ONDM


#Trait matrix -- Skewness
trait.matrix.s.ONDM<-as.matrix(Skew.norm.ONDM)
#Rho -- Skewness
rho.matrix.s.ONDM<- t(trait.matrix.s.ONDM) %*% mating.matrix.ONDM %*% trait.matrix.s.ONDM
rho.matrix.s.ONDM

# Trait matrix -- variance.
trait.matrix.v.ONDM<-as.matrix(Var.norm.ONDM) 
#Rho -- Variance
rho.matrix.v.ONDM <- t(trait.matrix.v.ONDM) %*% mating.matrix.ONDM %*% trait.matrix.v.ONDM
rho.matrix.v.ONDM

#Trait matrix -- Start date
trait.matrix.st.ONDM<-as.matrix(Start.date.norm.ONDM) 
#Rho -- Start date
rho.matrix.st.ONDM <- t(trait.matrix.st.ONDM) %*% mating.matrix.ONDM %*% trait.matrix.st.ONDM
rho.matrix.st.ONDM

#Trait matrix -- Duration
trait.matrix.d.ONDM<-as.matrix(Duration.norm.ONDM)
#Rho -- Duration
rho.matrix.d.ONDM <- t(trait.matrix.d.ONDM) %*% mating.matrix.ONDM %*% trait.matrix.d.ONDM
rho.matrix.d.ONDM
```

```{r}
##ONTI Population


##Create table of GAM predicted # of open flowers/day/individual for just ONTI population
ONTI<-subset(Flwr,Flwr$Pop=="ONTI")
ONTI
Individual_ID8<-unique(ONTI$Num) 
Individual_ID8<-Individual_ID8[Individual_ID8!=187]
Individual_ID8<-Individual_ID8[Individual_ID8!=440]

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONTI<-matrix(nrow=0,ncol=4)
colnames(MasterDataONTI)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID8)) {
  Focal<-subset(ONTI,ONTI$Num==Individual_ID8[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID8[i],length(AbsDay))) #Individual column
  NewDataONTI<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONTI<-rbind(MasterDataONTI,NewDataONTI) #New data frame containing information for all individuals
  print(Individual_ID8[i])
}

#PredictDay function for ONTI dataset
#PredictDayONTI<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count8=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID8)){
    count8=count8+1
  FocalFrame<-MasterDataONTI[MasterDataONTI$Individual==Individual_ID8[j],]
  Flowers<-PredictDay(Num=Individual_ID8[j],df=MasterDataONTI)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID8[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count8
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONTI_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONTI_Wide<-dplyr :: select(Mating.Matrix.Data.ONTI_Wide,-(Individual.x))  #Remove individual column.


##Mating matrix just ONTI population

flr.matrix.ONTI<-as.matrix(Mating.Matrix.Data.ONTI_Wide)
#Mother/Father matrices
mother.flr.matrix.ONTI<- flr.matrix.ONTI/sum(flr.matrix.ONTI)
father.colsum.ONTI<- apply(flr.matrix.ONTI, 2,  sum)
father.flr.matrix.ONTI<- apply(flr.matrix.ONTI, 1, function(d) d/father.colsum.ONTI) #don't understand this line
father.flr.matrix.ONTI[is.nan(father.flr.matrix.ONTI)]<-0
father.flr.matrix.ONTI[is.infinite(father.flr.matrix.ONTI)]<-0
mating.matrix.ONTI <- mother.flr.matrix.ONTI %*% father.flr.matrix.ONTI #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONTI<- sum(mating.matrix.ONTI) #should be 1

##Principal component analysis for S of ONTI population

prcomp(mating.matrix.ONTI,scale=FALSE)
X8<-eigen(mating.matrix.ONTI,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONTI
Y8<-X8$values
S.ONTI<-Y8[1]/sum(Y8)
S.ONTI



###Trait matrix and finding Rho for each trait ONTI
#Find moments
Kurtosis.ONTI<-c()
Skewness.ONTI<-c()
Variance.ONTI<-c()
Start.date.ONTI<-c()
End.date.ONTI<-c()
Duration.ONTI<-c()
count8=0
Mom.ONTI<-for( j in 1:length(Individual_ID8)){
    count8=count8+1
  Focal<-df3[df3$Individual.x==Individual_ID8[j],]
       pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONTI<-append(Kurtosis.ONTI,CoeffKurt)
  Skewness.ONTI<-append(Skewness.ONTI,CoeffSkew)
  Variance.ONTI<-append(Variance.ONTI,CoeffVar)
  Start.date.ONTI<-append(Start.date.ONTI,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONTI<-append(End.date.ONTI,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONTI[is.nan(Kurtosis.ONTI)]<-0
Skewness.ONTI[is.nan(Skewness.ONTI)]<-0
Variance.ONTI[is.nan(Variance.ONTI)]<-0


#Find probabilities of moments.
#KurtosisProb.ONTI<-Kurtosis.ONTI/sum(Kurtosis.ONTI)
#SkewnessProb.ONTI<-Skewness.ONTI/sum(Skewness.ONTI)
#VarianceProb.ONTI<-Variance.ONTI/sum(Variance.ONTI)

##Find average variance.
mean(Variance.ONTI)

###Find start date
#Start.date.ONTI<-as.numeric(names(Mating.Matrix.Data.ONTI_Wide)[apply(Mating.Matrix.Data.ONTI_Wide != 0, 1, which.max)])
#Start.date.ONTI

###Find end date
#End.date.ONTI<-as.numeric(names(Mating.Matrix.Data.ONTI_Wide)[max.col(Mating.Matrix.Data.ONTI_Wide != 0, 'last')])
#End.date.ONTI

###Find duration
Duration.ONTI<-End.date.ONTI-Start.date.ONTI

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.ONTI<-as.vector(scale(Kurtosis.ONTI))
Skew.norm.ONTI<-as.vector(scale(Skewness.ONTI))
Var.norm.ONTI<-as.vector(scale(Variance.ONTI))
Start.date.norm.ONTI<-as.vector(scale(Start.date.ONTI))
Duration.norm.ONTI<-as.vector(scale(Duration.ONTI))

#Trait matrix -- Kurtosis
trait.matrix.k.ONTI<-as.matrix(Kurt.norm.ONTI) 
#Rho  -- Kurtosis
rho.matrix.k.ONTI <- t(trait.matrix.k.ONTI) %*% mating.matrix.ONTI %*% trait.matrix.k.ONTI
rho.matrix.k.ONTI


#Trait matrix -- Skewness
trait.matrix.s.ONTI<-as.matrix(Skew.norm.ONTI)
#Rho -- Skewness
rho.matrix.s.ONTI <- t(trait.matrix.s.ONTI) %*% mating.matrix.ONTI %*% trait.matrix.s.ONTI
rho.matrix.s.ONTI

# Trait matrix -- variance.
trait.matrix.v.ONTI<-as.matrix(Var.norm.ONTI) 
#Rho -- Variance
rho.matrix.v.ONTI <- t(trait.matrix.v.ONTI) %*% mating.matrix.ONTI %*% trait.matrix.v.ONTI
rho.matrix.v.ONTI

#Trait matrix -- Start date
trait.matrix.st.ONTI<-as.matrix(Start.date.norm.ONTI) 
#Rho -- Start date
rho.matrix.st.ONTI <- t(trait.matrix.st.ONTI) %*% mating.matrix.ONTI %*% trait.matrix.st.ONTI
rho.matrix.st.ONTI

#Trait matrix -- Duration
trait.matrix.d.ONTI<-as.matrix(Duration.norm.ONTI)
#Rho -- Duration
rho.matrix.d.ONTI <- t(trait.matrix.d.ONTI) %*% mating.matrix.ONTI %*% trait.matrix.d.ONTI
rho.matrix.d.ONTI

```
```{r}
##ONWH Population


##Create table of GAM predicted # of open flowers/day/individual for just ONWH population
ONWH<-subset(Flwr,Flwr$Pop=="ONWH")
ONWH
Individual_ID9<-unique(ONWH$Num) 

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONWH<-matrix(nrow=0,ncol=4)
colnames(MasterDataONWH)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID9)) {
  Focal<-subset(ONWH,ONWH$Num==Individual_ID9[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID9[i],length(AbsDay))) #Individual column
  NewDataONWH<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONWH<-rbind(MasterDataONWH,NewDataONWH) #New data frame containing information for all individuals
  print(Individual_ID9[i])
}

#PredictDay function for ONWH dataset
#PredictDayONWH<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}

#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count9=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID9)){
    count9=count9+1
  FocalFrame<-MasterDataONWH[MasterDataONWH$Individual==Individual_ID9[j],]
  Flowers<-PredictDay(Num=Individual_ID9[j],df=MasterDataONWH)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID9[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count9
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONWH_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONWH_Wide<-dplyr :: select(Mating.Matrix.Data.ONWH_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just ONWH population

flr.matrix.ONWH<-as.matrix(Mating.Matrix.Data.ONWH_Wide)
#Mother/Father matrices
mother.flr.matrix.ONWH<- flr.matrix.ONWH/sum(flr.matrix.ONWH)
father.colsum.ONWH<- apply(flr.matrix.ONWH, 2,  sum)
father.flr.matrix.ONWH<- apply(flr.matrix.ONWH, 1, function(d) d/father.colsum.ONWH) #don't understand this line
father.flr.matrix.ONWH[is.nan(father.flr.matrix.ONWH)]<-0
father.flr.matrix.ONWH[is.infinite(father.flr.matrix.ONWH)]<-0
mating.matrix.ONWH <- mother.flr.matrix.ONWH %*% father.flr.matrix.ONWH #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONWH<- sum(mating.matrix.ONWH) #should be 1


##Principal component analysis for S of ONWH population

prcomp(mating.matrix.ONWH,scale=FALSE)
X9<-eigen(mating.matrix.ONWH,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONWH
Y9<-X9$values
S.ONWH<-Y9[1]/sum(Y9)
S.ONWH



###Trait matrix and finding Rho for each trait ONWH
#Find moments
Kurtosis.ONWH<-c()
Skewness.ONWH<-c()
Variance.ONWH<-c()
Start.date.ONWH<-c()
End.date.ONWH<-c()
Duration.ONWH<-c()
count9=0
Mom.ONWH<-for( j in 1:length(Individual_ID9)){
    count9=count9+1
  Focal<-df3[df3$Individual.x==Individual_ID9[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONWH<-append(Kurtosis.ONWH,CoeffKurt)
  Skewness.ONWH<-append(Skewness.ONWH,CoeffSkew)
  Variance.ONWH<-append(Variance.ONWH,CoeffVar)
  Start.date.ONWH<-append(Start.date.ONWH,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONWH<-append(End.date.ONWH,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONWH[is.nan(Kurtosis.ONWH)]<-0
Skewness.ONWH[is.nan(Skewness.ONWH)]<-0
Variance.ONWH[is.nan(Variance.ONWH)]<-0

#Find probabilities of moments.
#KurtosisProb.ONWH<-Kurtosis.ONWH/sum(Kurtosis.ONWH)
#SkewnessProb.ONWH<-Skewness.ONWH/sum(Skewness.ONWH)
#VarianceProb.ONWH<-Variance.ONWH/sum(Variance.ONWH)

##Find average variance.
mean(Variance.ONWH)

###Find start date 
#Start.date.ONWH<-as.numeric(names(Mating.Matrix.Data.ONWH_Wide)[apply(Mating.Matrix.Data.ONWH_Wide != 0, 1, which.max)])
#Start.date.ONWH

###Find end date
#End.date.ONWH<-as.numeric(names(Mating.Matrix.Data.ONWH_Wide)[max.col(Mating.Matrix.Data.ONWH_Wide != 0, 'last')])
#End.date.ONWH

###Find duration
Duration.ONWH<-End.date.ONWH-Start.date.ONWH

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.ONWH<-as.vector(scale(Kurtosis.ONWH))
Skew.norm.ONWH<-as.vector(scale(Skewness.ONWH))
Var.norm.ONWH<-as.vector(scale(Variance.ONWH))
Start.date.norm.ONWH<-as.vector(scale(Start.date.ONWH))
Duration.norm.ONWH<-as.vector(scale(Duration.ONWH))

#Trait matrix -- Kurtosis
trait.matrix.k.ONWH<-as.matrix(Kurt.norm.ONWH) 
#Rho  -- Kurtosis
rho.matrix.k.ONWH <- t(trait.matrix.k.ONWH) %*% mating.matrix.ONWH %*% trait.matrix.k.ONWH
rho.matrix.k.ONWH


#Trait matrix -- Skewness
trait.matrix.s.ONWH<-as.matrix(Skew.norm.ONWH)
#Rho -- Skewness
rho.matrix.s.ONWH <- t(trait.matrix.s.ONWH) %*% mating.matrix.ONWH %*% trait.matrix.s.ONWH
rho.matrix.s.ONWH

# Trait matrix -- variance.
trait.matrix.v.ONWH<-as.matrix(Var.norm.ONWH) 
#Rho -- Variance
rho.matrix.v.ONWH <- t(trait.matrix.v.ONWH) %*% mating.matrix.ONWH %*% trait.matrix.v.ONWH
rho.matrix.v.ONWH 

#Trait matrix -- Start date
trait.matrix.st.ONWH<-as.matrix(Start.date.norm.ONWH) 
#Rho -- Start date
rho.matrix.st.ONWH <- t(trait.matrix.st.ONWH) %*% mating.matrix.ONWH %*% trait.matrix.st.ONWH
rho.matrix.st.ONWH

#Trait matrix -- Duration
trait.matrix.d.ONWH<-as.matrix(Duration.norm.ONWH)
#Rho -- Duration
rho.matrix.d.ONWH <- t(trait.matrix.d.ONWH) %*% mating.matrix.ONWH %*% trait.matrix.d.ONWH
rho.matrix.d.ONWH

```
```{r}
##NJHP Population


##Create table of GAM predicted # of open flowers/day/individual for just NJHP population
NJHP<-subset(Flwr,Flwr$Pop=="NJHP")
NJHP
Individual_ID10<-unique(NJHP$Num) 

##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataNJHP<-matrix(nrow=0,ncol=4)
colnames(MasterDataNJHP)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID10)) {
  Focal<-subset(NJHP,NJHP$Num==Individual_ID10[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID10[i],length(AbsDay))) #Individual column
  NewDataNJHP<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataNJHP<-rbind(MasterDataNJHP,NewDataNJHP) #New data frame containing information for all individuals
  print(Individual_ID10[i])
}

#PredictDay function for NJHP dataset
#PredictDayNJHP<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count10=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID10)){
    count10=count10+1
  FocalFrame<-MasterDataNJHP[MasterDataNJHP$Individual==Individual_ID10[j],]
  Flowers<-PredictDay(Num=Individual_ID10[j],df=MasterDataNJHP)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID10[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count10
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.NJHP_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.NJHP_Wide<-dplyr :: select(Mating.Matrix.Data.NJHP_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just NJHP population

flr.matrix.NJHP<-as.matrix(Mating.Matrix.Data.NJHP_Wide)
#Mother/Father matrices
mother.flr.matrix.NJHP<- flr.matrix.NJHP/sum(flr.matrix.NJHP)
father.colsum.NJHP<- apply(flr.matrix.NJHP, 2,  sum)
father.flr.matrix.NJHP<- apply(flr.matrix.NJHP, 1, function(d) d/father.colsum.NJHP) #don't understand this line
father.flr.matrix.NJHP[is.nan(father.flr.matrix.NJHP)]<-0
father.flr.matrix.NJHP[is.infinite(father.flr.matrix.NJHP)]<-0
mating.matrix.NJHP <- mother.flr.matrix.NJHP %*% father.flr.matrix.NJHP #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.NJHP<- sum(mating.matrix.NJHP) #should be 1


##Principal component analysis for S of NJHP population

prcomp(mating.matrix.NJHP,scale=FALSE)
X10<-eigen(mating.matrix.NJHP,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for NJHP
Y10<-X10$values
S.NJHP<-Y10[1]/sum(Y10)
S.NJHP



###Trait matrix and finding Rho for each trait NJHP
#Find moments
Kurtosis.NJHP<-c()
Skewness.NJHP<-c()
Variance.NJHP<-c()
Start.date.NJHP<-c()
End.date.NJHP<-c()
Duration.NJHP<-c()
count10=0
Mom.NJHP<-for( j in 1:length(Individual_ID10)){
    count10=count10+1
  Focal<-df3[df3$Individual.x==Individual_ID10[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.NJHP<-append(Kurtosis.NJHP,CoeffKurt)
  Skewness.NJHP<-append(Skewness.NJHP,CoeffSkew)
  Variance.NJHP<-append(Variance.NJHP,CoeffVar)
  Start.date.NJHP<-append(Start.date.NJHP,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.NJHP<-append(End.date.NJHP,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.NJHP[is.nan(Kurtosis.NJHP)]<-0
Skewness.NJHP[is.nan(Skewness.NJHP)]<-0
Variance.NJHP[is.nan(Variance.NJHP)]<-0

#Find probabilities of each moment.
#KurtosisProb.NJHP<-Kurtosis.NJHP/sum(Kurtosis.NJHP)
#SkewnessProb.NJHP<-Skewness.NJHP/sum(Skewness.NJHP)
#VarianceProb.NJHP<-Variance.NJHP/sum(Variance.NJHP)


##Find average variance.
mean(Variance.NJHP)

###Find start date
#Start.date.NJHP<-as.numeric(names(Mating.Matrix.Data.NJHP_Wide)[apply(Mating.Matrix.Data.NJHP_Wide != 0, 1, which.max)])
#Start.date.NJHP

###Find end date
#End.date.NJHP<-as.numeric(names(Mating.Matrix.Data.NJHP_Wide)[max.col(Mating.Matrix.Data.NJHP_Wide != 0, 'last')])
#End.date.NJHP

###Find duration
Duration.NJHP<-End.date.NJHP-Start.date.NJHP

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.NJHP<-as.vector(scale(Kurtosis.NJHP))
Skew.norm.NJHP<-as.vector(scale(Skewness.NJHP))
Var.norm.NJHP<-as.vector(scale(Variance.NJHP))
Start.date.norm.NJHP<-as.vector(scale(Start.date.NJHP))
Duration.norm.NJHP<-as.vector(scale(Duration.NJHP))

#Trait matrix -- Kurtosis
trait.matrix.k.NJHP<-as.matrix(Kurt.norm.NJHP) 
#Rho  -- Kurtosis
rho.matrix.k.NJHP <- t(trait.matrix.k.NJHP) %*% mating.matrix.NJHP %*% trait.matrix.k.NJHP
rho.matrix.k.NJHP


#Trait matrix -- Skewness
trait.matrix.s.NJHP<-as.matrix(Skew.norm.NJHP)
#Rho -- Skewness
rho.matrix.s.NJHP <- t(trait.matrix.s.NJHP) %*% mating.matrix.NJHP %*% trait.matrix.s.NJHP
rho.matrix.s.NJHP

# Trait matrix -- variance.
trait.matrix.v.NJHP<-as.matrix(Var.norm.NJHP) 
#Rho -- Variance
rho.matrix.v.NJHP <- t(trait.matrix.v.NJHP) %*% mating.matrix.NJHP %*% trait.matrix.v.NJHP
rho.matrix.v.NJHP

#Trait matrix -- Start date
trait.matrix.st.NJHP<-as.matrix(Start.date.norm.NJHP) 
#Rho -- Start date
rho.matrix.st.NJHP <- t(trait.matrix.st.NJHP) %*% mating.matrix.NJHP %*% trait.matrix.st.NJHP
rho.matrix.st.NJHP

#Trait matrix -- Duration
trait.matrix.d.NJHP<-as.matrix(Duration.norm.NJHP)
#Rho -- Duration
rho.matrix.d.NJHP <- t(trait.matrix.d.NJHP) %*% mating.matrix.NJHP %*% trait.matrix.d.NJHP
rho.matrix.d.NJHP

```
```{r}
##ONNO Population


##Create table of GAM predicted # of open flowers/day/individual for just ONNO population
ONNO<-subset(Flwr,Flwr$Pop=="ONNO")
ONNO
Individual_ID11<-unique(ONNO$Num) 


##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONNO<-matrix(nrow=0,ncol=4)
colnames(MasterDataONNO)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID11)) {
  Focal<-subset(ONNO,ONNO$Num==Individual_ID11[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID11[i],length(AbsDay))) #Individual column
  NewDataONNO<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONNO<-rbind(MasterDataONNO,NewDataONNO) #New data frame containing information for all individuals
  print(Individual_ID11[i])
}



#PredictDay function for ONNO dataset
#PredictDayONNO<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count11=0
#For-loop
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID11)){
    count11=count11+1
  FocalFrame<-MasterDataONNO[MasterDataONNO$Individual==Individual_ID11[j],]
  Flowers<-PredictDay(Num=Individual_ID11[j],df=MasterDataONNO)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID11[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count11
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONNO_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONNO_Wide<-dplyr :: select(Mating.Matrix.Data.ONNO_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just ONNO population

flr.matrix.ONNO<-as.matrix(Mating.Matrix.Data.ONNO_Wide)
#Mother/Father matrices
mother.flr.matrix.ONNO<- flr.matrix.ONNO/sum(flr.matrix.ONNO)
father.colsum.ONNO<- apply(flr.matrix.ONNO, 2,  sum)
father.flr.matrix.ONNO<- apply(flr.matrix.ONNO, 1, function(d) d/father.colsum.ONNO) 
father.flr.matrix.ONNO[is.nan(father.flr.matrix.ONNO)]<-0
father.flr.matrix.ONNO[is.infinite(father.flr.matrix.ONNO)]<-0
mating.matrix.ONNO <- mother.flr.matrix.ONNO %*% father.flr.matrix.ONNO #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONNO<- sum(mating.matrix.ONNO) #should be 1


##Principal component analysis for S of ONNO population

prcomp(mating.matrix.ONNO,scale=FALSE)
X11<-eigen(mating.matrix.ONNO,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONNO
Y11<-X11$values
S.ONNO<-Y11[1]/sum(Y11)
S.ONNO



###Trait matrix and finding Rho for each trait ONNO
#Find moments
Kurtosis.ONNO<-c()
Skewness.ONNO<-c()
Variance.ONNO<-c()
Start.date.ONNO<-c()
End.date.ONNO<-c()
Duration.ONNO<-c()
count11=0
Mom.ONNO<-for( j in 1:length(Individual_ID11)){
    count11=count11+1
  Focal<-df3[df3$Individual.x==Individual_ID11[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONNO<-append(Kurtosis.ONNO,CoeffKurt)
  Skewness.ONNO<-append(Skewness.ONNO,CoeffSkew)
  Variance.ONNO<-append(Variance.ONNO,CoeffVar)
  Start.date.ONNO<-append(Start.date.ONNO,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONNO<-append(End.date.ONNO,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONNO[is.nan(Kurtosis.ONNO)]<-0
Skewness.ONNO[is.nan(Skewness.ONNO)]<-0
Variance.ONNO[is.nan(Variance.ONNO)]<-0

#Find probabilities of each moment.
#KurtosisProb.ONNO<-Kurtosis.ONNO/sum(Kurtosis.ONNO)
#SkewnessProb.ONNO<-Skewness.ONNO/sum(Skewness.ONNO)
#VarianceProb.ONNO<-Variance.ONNO/sum(Variance.ONNO)

##Find average variance.
mean(Variance.ONNO)


###Find start date
#Start.date.ONNO<-as.numeric(names(Mating.Matrix.Data.ONNO_Wide)[apply(Mating.Matrix.Data.ONNO_Wide != 0, 1, which.max)])
#Start.date.ONNO

###Find end date
#End.date.ONNO<-as.numeric(names(Mating.Matrix.Data.ONNO_Wide)[max.col(Mating.Matrix.Data.ONNO_Wide != 0, 'last')])
#End.date.ONNO

###Find duration
Duration.ONNO<-End.date.ONNO-Start.date.ONNO

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.ONNO<-as.vector(scale(Kurtosis.ONNO))
Skew.norm.ONNO<-as.vector(scale(Skewness.ONNO))
Var.norm.ONNO<-as.vector(scale(Variance.ONNO))
Start.date.norm.ONNO<-as.vector(scale(Start.date.ONNO))
Duration.norm.ONNO<-as.vector(scale(Duration.ONNO))

#Trait matrix -- Kurtosis
trait.matrix.k.ONNO<-as.matrix(Kurt.norm.ONNO) 
#Rho  -- Kurtosis
rho.matrix.k.ONNO <- t(trait.matrix.k.ONNO) %*% mating.matrix.ONNO %*% trait.matrix.k.ONNO
rho.matrix.k.ONNO


#Trait matrix -- Skewness
trait.matrix.s.ONNO<-as.matrix(Skew.norm.ONNO)
#Rho -- Skewness
rho.matrix.s.ONNO <- t(trait.matrix.s.ONNO) %*% mating.matrix.ONNO %*% trait.matrix.s.ONNO
rho.matrix.s.ONNO

# Trait matrix -- variance.
trait.matrix.v.ONNO<-as.matrix(Var.norm.ONNO) 
#Rho -- Variance
rho.matrix.v.ONNO <- t(trait.matrix.v.ONNO) %*% mating.matrix.ONNO %*% trait.matrix.v.ONNO
rho.matrix.v.ONNO

#Trait matrix -- Start date
trait.matrix.st.ONNO<-as.matrix(Start.date.norm.ONNO) 
#Rho -- Start date
rho.matrix.st.ONNO <- t(trait.matrix.st.ONNO) %*% mating.matrix.ONNO %*% trait.matrix.st.ONNO
rho.matrix.st.ONNO

#Trait matrix -- Duration
trait.matrix.d.ONNO<-as.matrix(Duration.norm.ONNO)
#Rho -- Duration
rho.matrix.d.ONNO <- t(trait.matrix.d.ONNO) %*% mating.matrix.ONNO %*% trait.matrix.d.ONNO
rho.matrix.d.ONNO

```
```{r}
##NYCH Population


##Create table of GAM predicted # of open flowers/day/individual for just NYCH population
NYCH<-subset(Flwr,Flwr$Pop=="NYCH")
NYCH
Individual_ID12<-unique(NYCH$Num) 
Individual_ID12<-Individual_ID12[Individual_ID12!=187]


##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataNYCH<-matrix(nrow=0,ncol=4)
colnames(MasterDataNYCH)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID12)) {
  Focal<-subset(NYCH,NYCH$Num==Individual_ID12[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID12[i],length(AbsDay))) #Individual column
  NewDataNYCH<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataNYCH<-rbind(MasterDataNYCH,NewDataNYCH) #New data frame containing information for all individuals
  print(Individual_ID12[i])
}

#PredictDay function for NYCH dataset
#PredictDayNYCH<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count12=0
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID12)){
    count12=count12+1
  FocalFrame<-MasterDataNYCH[MasterDataNYCH$Individual==Individual_ID12[j],]
  Flowers<-PredictDay(Num=Individual_ID12[j],df=MasterDataNYCH)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID12[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count12
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.NYCH_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.NYCH_Wide<-dplyr :: select(Mating.Matrix.Data.NYCH_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just NYCH population

flr.matrix.NYCH<-as.matrix(Mating.Matrix.Data.NYCH_Wide)
#Mother/Father matrices
mother.flr.matrix.NYCH<- flr.matrix.NYCH/sum(flr.matrix.NYCH)
father.colsum.NYCH<- apply(flr.matrix.NYCH, 2,  sum)
father.flr.matrix.NYCH<- apply(flr.matrix.NYCH, 1, function(d) d/father.colsum.NYCH) 
father.flr.matrix.NYCH[is.nan(father.flr.matrix.NYCH)]<-0
father.flr.matrix.NYCH[is.infinite(father.flr.matrix.NYCH)]<-0
mating.matrix.NYCH <- mother.flr.matrix.NYCH %*% father.flr.matrix.NYCH #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.NYCH<- sum(mating.matrix.NYCH) #should be 1


##Principal component analysis for S of NYCH population

prcomp(mating.matrix.NYCH,scale=FALSE)
X12<-eigen(mating.matrix.NYCH,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for NYCH
Y12<-X12$values
S.NYCH<-Y12[1]/sum(Y12)
S.NYCH



###Trait matrix and finding Rho for each trait NYCH
#Find moments
Kurtosis.NYCH<-c()
Skewness.NYCH<-c()
Variance.NYCH<-c()
Start.date.NYCH<-c()
End.date.NYCH<-c()
Duration.NYCH<-c()
count12=0
Mom.NYCH<-for( j in 1:length(Individual_ID12)){
    count12=count12+1
  Focal<-df3[df3$Individual.x==Individual_ID12[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.NYCH<-append(Kurtosis.NYCH,CoeffKurt)
  Skewness.NYCH<-append(Skewness.NYCH,CoeffSkew)
  Variance.NYCH<-append(Variance.NYCH,CoeffVar)
  Start.date.NYCH<-append(Start.date.NYCH,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.NYCH<-append(End.date.NYCH,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.NYCH[is.nan(Kurtosis.NYCH)]<-0
Skewness.NYCH[is.nan(Skewness.NYCH)]<-0
Variance.NYCH[is.nan(Variance.NYCH)]<-0

#Find probabilities of moments.
#KurtosisProb.NYCH<-Kurtosis.NYCH/sum(Kurtosis.NYCH)
#SkewnessProb.NYCH<-Skewness.NYCH/sum(Skewness.NYCH)
#VarianceProb.NYCH<-Variance.NYCH/sum(Variance.NYCH)

##Find average variance.
mean(Variance.NYCH)

###Find start date
#Start.date.NYCH<-as.numeric(names(Mating.Matrix.Data.NYCH_Wide)[apply(Mating.Matrix.Data.NYCH_Wide != 0, 1, which.max)])
#Start.date.NYCH

###Find end date
#End.date.NYCH<-as.numeric(names(Mating.Matrix.Data.NYCH_Wide)[max.col(Mating.Matrix.Data.NYCH_Wide != 0, 'last')])
#End.date.NYCH

###Find duration
Duration.NYCH<-End.date.NYCH-Start.date.NYCH

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.NYCH<-as.vector(scale(Kurtosis.NYCH))
Skew.norm.NYCH<-as.vector(scale(Skewness.NYCH))
Var.norm.NYCH<-as.vector(scale(Variance.NYCH))
Start.date.norm.NYCH<-as.vector(scale(Start.date.NYCH))
Duration.norm.NYCH<-as.vector(scale(Duration.NYCH))

#Trait matrix -- Kurtosis
trait.matrix.k.NYCH<-as.matrix(Kurt.norm.NYCH) 
#Rho  -- Kurtosis
rho.matrix.k.NYCH <- t(trait.matrix.k.NYCH) %*% mating.matrix.NYCH %*% trait.matrix.k.NYCH
rho.matrix.k.NYCH


#Trait matrix -- Skewness
trait.matrix.s.NYCH<-as.matrix(Skew.norm.NYCH)
#Rho -- Skewness
rho.matrix.s.NYCH <- t(trait.matrix.s.NYCH) %*% mating.matrix.NYCH %*% trait.matrix.s.NYCH
rho.matrix.s.NYCH

# Trait matrix -- variance.
trait.matrix.v.NYCH<-as.matrix(Var.norm.NYCH) 
#Rho -- Variance
rho.matrix.v.NYCH <- t(trait.matrix.v.NYCH) %*% mating.matrix.NYCH %*% trait.matrix.v.NYCH
rho.matrix.v.NYCH

#Trait matrix -- Start date
trait.matrix.st.NYCH<-as.matrix(Start.date.norm.NYCH) 
#Rho -- Start date
rho.matrix.st.NYCH <- t(trait.matrix.st.NYCH) %*% mating.matrix.NYCH %*% trait.matrix.st.NYCH
rho.matrix.st.NYCH

#Trait matrix -- Duration
trait.matrix.d.NYCH<-as.matrix(Duration.norm.NYCH)
#Rho -- Duration
rho.matrix.d.NYCH <- t(trait.matrix.d.NYCH) %*% mating.matrix.NYCH %*% trait.matrix.d.NYCH
rho.matrix.d.NYCH

```
```{r}
##ONPG Population


##Create table of GAM predicted # of open flowers/day/individual for just ONPG population
ONPG<-subset(Flwr,Flwr$Pop=="ONPG")
ONPG
Individual_ID13<-unique(ONPG$Num) 


##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataONPG<-matrix(nrow=0,ncol=4)
colnames(MasterDataONPG)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID13)) {
  Focal<-subset(ONPG,ONPG$Num==Individual_ID13[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID13[i],length(AbsDay))) #Individual column
  NewDataONPG<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataONPG<-rbind(MasterDataONPG,NewDataONPG) #New data frame containing information for all individuals
  print(Individual_ID13[i])
}



#PredictDay function for ONPG dataset
#PredictDayONPG<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}


#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count13=0
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID13)){
    count13=count13+1
  FocalFrame<-MasterDataONPG[MasterDataONPG$Individual==Individual_ID13[j],]
  Flowers<-PredictDay(Num=Individual_ID13[j],df=MasterDataONPG)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID13[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count13
dfset0<-df3



#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.ONPG_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.ONPG_Wide<-dplyr :: select(Mating.Matrix.Data.ONPG_Wide,-(Individual.x))  #Remove individual column.


##Mating matrix just ONPG population

flr.matrix.ONPG<-as.matrix(Mating.Matrix.Data.ONPG_Wide)
#Mother/Father matrices
mother.flr.matrix.ONPG<- flr.matrix.ONPG/sum(flr.matrix.ONPG)
father.colsum.ONPG<- apply(flr.matrix.ONPG, 2,  sum)
father.flr.matrix.ONPG<- apply(flr.matrix.ONPG, 1, function(d) d/father.colsum.ONPG) 
father.flr.matrix.ONPG[is.nan(father.flr.matrix.ONPG)]<-0
father.flr.matrix.ONPG[is.infinite(father.flr.matrix.ONPG)]<-0
mating.matrix.ONPG <- mother.flr.matrix.ONPG %*% father.flr.matrix.ONPG #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.ONPG<- sum(mating.matrix.ONPG) #should be 1


##Principal component analysis for S of ONNO population

prcomp(mating.matrix.ONPG,scale=FALSE)
X13<-eigen(mating.matrix.ONPG,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for ONNO
Y13<-X13$values
S.ONPG<-Y13[1]/sum(Y13)
S.ONPG



###Trait matrix and finding Rho for each trait ONNO
#Find moments
Kurtosis.ONPG<-c()
Skewness.ONPG<-c()
Variance.ONPG<-c()
Start.date.ONPG<-c()
End.date.ONPG<-c()
Duration.ONPG<-c()
count13=0
Mom.ONPG<-for( j in 1:length(Individual_ID13)){
    count13=count13+1
  Focal<-df3[df3$Individual.x==Individual_ID13[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.ONPG<-append(Kurtosis.ONPG,CoeffKurt)
  Skewness.ONPG<-append(Skewness.ONPG,CoeffSkew)
  Variance.ONPG<-append(Variance.ONPG,CoeffVar)
  Start.date.ONPG<-append(Start.date.ONPG,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.ONPG<-append(End.date.ONPG,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.ONPG[is.nan(Kurtosis.ONPG)]<-0
Skewness.ONPG[is.nan(Skewness.ONPG)]<-0
Variance.ONPG[is.nan(Variance.ONPG)]<-0

#Find probabilities of moments.
#KurtosisProb.ONPG<-Kurtosis.ONPG/sum(Kurtosis.ONPG)
#SkewnessProb.ONPG<-Skewness.ONPG/sum(Skewness.ONPG)
#VarianceProb.ONPG<-Variance.ONPG/sum(Variance.ONPG)

##Find average variance.
mean(Variance.ONPG)

###Find start date
#Start.date.ONPG<-as.numeric(names(Mating.Matrix.Data.ONPG_Wide)[apply(Mating.Matrix.Data.ONPG_Wide != 0, 1, which.max)])
#Start.date.ONPG

###Find end date
#End.date.ONPG<-as.numeric(names(Mating.Matrix.Data.ONPG_Wide)[max.col(Mating.Matrix.Data.ONPG_Wide != 0, 'last')])
#End.date.ONPG

###Find duration
Duration.ONPG<-End.date.ONPG-Start.date.ONPG

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.ONPG<-as.vector(scale(Kurtosis.ONPG))
Skew.norm.ONPG<-as.vector(scale(Skewness.ONPG))
Var.norm.ONPG<-as.vector(scale(Variance.ONPG))
Start.date.norm.ONPG<-as.vector(scale(Start.date.ONPG))
Duration.norm.ONPG<-as.vector(scale(Duration.ONPG))

#Trait matrix -- Kurtosis
trait.matrix.k.ONPG<-as.matrix(Kurt.norm.ONPG) 
#Rho  -- Kurtosis
rho.matrix.k.ONPG <- t(trait.matrix.k.ONPG) %*% mating.matrix.ONPG %*% trait.matrix.k.ONPG
rho.matrix.k.ONPG


#Trait matrix -- Skewness
trait.matrix.s.ONPG<-as.matrix(Skew.norm.ONPG)
#Rho -- Skewness
rho.matrix.s.ONPG <- t(trait.matrix.s.ONPG) %*% mating.matrix.ONPG %*% trait.matrix.s.ONPG
rho.matrix.s.ONPG

# Trait matrix -- variance.
trait.matrix.v.ONPG<-as.matrix(Var.norm.ONPG) 
#Rho -- Variance
rho.matrix.v.ONPG <- t(trait.matrix.v.ONPG) %*% mating.matrix.ONPG %*% trait.matrix.v.ONPG
rho.matrix.v.ONPG

#Trait matrix -- Start date
trait.matrix.st.ONPG<-as.matrix(Start.date.norm.ONPG) 
#Rho -- Start date
rho.matrix.st.ONPG <- t(trait.matrix.st.ONPG) %*% mating.matrix.ONPG %*% trait.matrix.st.ONPG
rho.matrix.st.ONPG

#Trait matrix -- Duration
trait.matrix.d.ONPG<-as.matrix(Duration.norm.ONPG)
#Rho -- Duration
rho.matrix.d.ONPG <- t(trait.matrix.d.ONPG) %*% mating.matrix.ONPG %*% trait.matrix.d.ONPG
rho.matrix.d.ONPG

```
```{r}
##NJPT Population


##Create table of GAM predicted # of open flowers/day/individual for just NJPT population
NJPT<-subset(Flwr,Flwr$Pop=="NJPT")
NJPT
Individual_ID14<-unique(NJPT$Num) 


##Extend AbsDay to be 0:125 with OpFlwr values being 0 on added rows of AbsDay, while retaining information on when OpFlwr values of 0 were added.
MasterDataNJPT<-matrix(nrow=0,ncol=4)
colnames(MasterDataNJPT)<-c("AbsDay","OpFlwr","Individual","Added0")
for (i in 1:length(Individual_ID14)) {
  Focal<-subset(NJPT,NJPT$Num==Individual_ID14[i])
  Start<-min(Focal$AbsDay)-1 #Day that flowering was observed to start.
  End<-max(Focal$AbsDay)+1 #Day that flowering was observed to end.
    if (End == 126|End == 125) { #Trouble shooting for when flowering end date was 125 or 126.
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr) #rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr
    AbsDay<-c(0:Start,Focal$AbsDay)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr))) #column with information on which OpFlwr values are added 0s.
  } 
  else {
    OpFlwr<-c(rep(NA,length(0:Start)),Focal$OpFlwr,rep(NA,length(End:125)))#rep 0 for OpFlwr until start of flowering, then use observed values of OpFlwr until end of observed flowering, then rep 0
    AbsDay<-c(0:Start,Focal$AbsDay,End:125)
    Added0<-c(rep("yes",length(0:Start)),rep("no",length(Focal$OpFlwr)),rep("yes",length(End:125)))#column with information on which OpFlwr values are added 0s.
  }
  Individual<-c(rep(Individual_ID14[i],length(AbsDay))) #Individual column
  NewDataNJPT<-data.frame(AbsDay,OpFlwr,Individual,Added0) #New data frame for each individual
  MasterDataNJPT<-rbind(MasterDataNJPT,NewDataNJPT) #New data frame containing information for all individuals
  print(Individual_ID14[i])
}

#PredictDay function for NJPT dataset
#PredictDayNJPT<-function(Num,days=c(0:125),df){
#  Mod1<-gam(OpFlwr~s(AbsDay),data=df[df$Individual==Num,]) #Fitting Gam model.
#  PredDay<-predict(Mod1,newdata=data.frame(AbsDay=c(0:125))) #Predicting data over all days.
#  PredDay[PredDay<0]<-0 #Changing negative values to zero.
#return(PredDay)
#}



#For-loop
Days<-c()
Individual<-c()
Flowers<-c()
count14=0
df3<-matrix(ncol=6,nrow=0)
colnames(df3)<-c("Flowers","Individual.x","Days","OpFlwr","Individual.y","Added0")
for( j in 1:length(Individual_ID14)){
    count14=count14+1
  FocalFrame<-MasterDataNJPT[MasterDataNJPT$Individual==Individual_ID14[j],]
  Flowers<-PredictDay(Num=Individual_ID14[j],df=MasterDataNJPT)#Here use j to subset each individual in the individual ID vector. 
  Individual<-rep(Individual_ID14[j], times=length(0:125)) #Here to identify the individual, we also need to subset the Individual_ID vector instead. 
  Days<-0:125
  df1<-data.frame(Flowers,Individual,Days)
  df2<-df1 %>% left_join(FocalFrame,by=c("Days"="AbsDay")) #Joining new data frame (with GAM predictions) with raw data frame.
  df3<-rbind(df3,df2)
}
count14
dfset0<-df3


#Convert the data to wide format
dfset0<-dplyr :: select(dfset0,Flowers,Individual.x,Days,-(OpFlwr:Added0)) #Remove unnecessary columns.
Mating.Matrix.Data.NJPT_Wide<-dfset0 %>% pivot_wider(names_from = Days,values_from = Flowers) #Convert to wide format. 
Mating.Matrix.Data.NJPT_Wide<-dplyr :: select(Mating.Matrix.Data.NJPT_Wide,-(Individual.x))  #Remove individual column.

##Mating matrix just NJPT population

flr.matrix.NJPT<-as.matrix(Mating.Matrix.Data.NJPT_Wide)
#Mother/Father matrices
mother.flr.matrix.NJPT<- flr.matrix.NJPT/sum(flr.matrix.NJPT)
father.colsum.NJPT<- apply(flr.matrix.NJPT, 2,  sum)
father.flr.matrix.NJPT<- apply(flr.matrix.NJPT, 1, function(d) d/father.colsum.NJPT) 
father.flr.matrix.NJPT[is.nan(father.flr.matrix.NJPT)]<-0
father.flr.matrix.NJPT[is.infinite(father.flr.matrix.NJPT)]<-0
mating.matrix.NJPT <- mother.flr.matrix.NJPT %*% father.flr.matrix.NJPT #Creates mating matrix where each element is the proportion of all matings over all days between mother "i" and father "j" - the "phi" matrix
sum.mating.matrix.NJPT<- sum(mating.matrix.NJPT) #should be 1


##Principal component analysis for S of NJPT population

prcomp(mating.matrix.NJPT,scale=FALSE)
X14<-eigen(mating.matrix.NJPT,symmetric=TRUE,only.values=TRUE) #Difference in output between symmetric=TRUE and symmetric=FALSE is that when set to FALSE, same values are outputed but there is "+0.00e+00i" addition

##Finding S for NJPT
Y14<-X14$values
S.NJPT<-Y14[1]/sum(Y14)
S.NJPT



###Trait matrix and finding Rho for each trait ONNO
#Find moments
Kurtosis.NJPT<-c()
Skewness.NJPT<-c()
Variance.NJPT<-c()
Start.date.NJPT<-c()
End.date.NJPT<-c()
Duration.NJPT<-c()
count14=0
Mom.NJPT<-for( j in 1:length(Individual_ID14)){
    count14=count14+1
  Focal<-df3[df3$Individual.x==Individual_ID14[j],]
        pDays<-Focal$OpFlwr/sum(Focal$OpFlwr,na.rm=TRUE) #Proportion of total flowers that fall on each day
  WeightDays<-Focal$Days*pDays #Weight days by the proportion of total flowers open on that day 
  Mean<-sum(WeightDays,na.rm=TRUE) 
  Var<-sum((WeightDays-Mean)^2*pDays,na.rm=TRUE)
  CoeffVar<-Var/(Mean)
  CoeffKurt<-sum((WeightDays-Mean)^4*pDays,na.rm=TRUE)/sqrt(Var)
  CoeffSkew<-sum((WeightDays-Mean)^3*pDays,na.rm=TRUE)/sqrt(Var)
  Kurtosis.NJPT<-append(Kurtosis.NJPT,CoeffKurt)
  Skewness.NJPT<-append(Skewness.NJPT,CoeffSkew)
  Variance.NJPT<-append(Variance.NJPT,CoeffVar)
  Start.date.NJPT<-append(Start.date.NJPT,min(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
  End.date.NJPT<-append(End.date.NJPT,max(Focal$Days[Focal$OpFlwr!=0],na.rm=TRUE))
} 

Kurtosis.NJPT[is.nan(Kurtosis.NJPT)]<-0
Skewness.NJPT[is.nan(Skewness.NJPT)]<-0
Variance.NJPT[is.nan(Variance.NJPT)]<-0

#Find probabilities of moments. 
#KurtosisProb.NJPT<-Kurtosis.NJPT/sum(Kurtosis.NJPT)
#SkewnessProb.NJPT<-Skewness.NJPT/sum(Skewness.NJPT)
#VarianceProb.NJPT<-Variance.NJPT/sum(Variance.NJPT)

##Finding average variance.
mean(Variance.NJPT)

###Find start date
#Start.date.NJPT<-as.numeric(names(Mating.Matrix.Data.NJPT_Wide)[apply(Mating.Matrix.Data.NJPT_Wide != 0, 1, which.max)])
#Start.date.NJPT

###Find end date
#End.date.NJPT<-as.numeric(names(Mating.Matrix.Data.NJPT_Wide)[max.col(Mating.Matrix.Data.NJPT_Wide != 0, 'last')])
#End.date.NJPT

###Find duration
Duration.NJPT<-End.date.NJPT-Start.date.NJPT

###Vector of PC1 ####

##Find z -- vector containing the normalized phenotypic value 
Kurt.norm.NJPT<-as.vector(scale(Kurtosis.NJPT))
Skew.norm.NJPT<-as.vector(scale(Skewness.NJPT))
Var.norm.NJPT<-as.vector(scale(Variance.NJPT))
Start.date.norm.NJPT<-as.vector(scale(Start.date.NJPT))
Duration.norm.NJPT<-as.vector(scale(Duration.NJPT))

#Trait matrix -- Kurtosis
trait.matrix.k.NJPT<-as.matrix(Kurt.norm.NJPT) 
#Rho  -- Kurtosis
rho.matrix.k.NJPT <- t(trait.matrix.k.NJPT) %*% mating.matrix.NJPT %*% trait.matrix.k.NJPT
rho.matrix.k.NJPT


#Trait matrix -- Skewness
trait.matrix.s.NJPT<-as.matrix(Skew.norm.NJPT)
#Rho -- Skewness
rho.matrix.s.NJPT <- t(trait.matrix.s.NJPT) %*% mating.matrix.NJPT %*% trait.matrix.s.NJPT
rho.matrix.s.NJPT

# Trait matrix -- variance.
trait.matrix.v.NJPT<-as.matrix(Var.norm.NJPT) 
#Rho -- Variance
rho.matrix.v.NJPT <- t(trait.matrix.v.NJPT) %*% mating.matrix.NJPT %*% trait.matrix.v.NJPT
rho.matrix.v.NJPT

#Trait matrix -- Start date
trait.matrix.st.NJPT<-as.matrix(Start.date.norm.NJPT) 
#Rho -- Start date
rho.matrix.st.NJPT <- t(trait.matrix.st.NJPT) %*% mating.matrix.NJPT %*% trait.matrix.st.NJPT
rho.matrix.st.NJPT

#Trait matrix -- Duration
trait.matrix.d.NJPT<-as.matrix(Duration.norm.NJPT)
#Rho -- Duration
rho.matrix.d.NJPT <- t(trait.matrix.d.NJPT) %*% mating.matrix.NJPT %*% trait.matrix.d.NJPT
rho.matrix.d.NJPT

```
```{r}
#Mean kurtosis probability x population code
mean(Kurtosis.ONEC) 
mean(Kurtosis.ONRO)
mean(Kurtosis.NYSC)
mean(Kurtosis.NYLV)
mean(Kurtosis.ONDM)
mean(Kurtosis.ONTI)
mean(Kurtosis.MDDB)
mean(Kurtosis.ONWH)
mean(Kurtosis.NJHP)
mean(Kurtosis.ONNO)
mean(Kurtosis.NYCH)
mean(Kurtosis.ONPG)
mean(Kurtosis.NJPT) 


#Mean skewness x population code
mean(Skewness.ONEC)
mean(Skewness.ONRO)
mean(Skewness.NYSC)
mean(Skewness.NYLV)
mean(Skewness.ONDM)
mean(Skewness.ONTI)
mean(Skewness.MDDB)
mean(Skewness.ONWH)
mean(Skewness.NJHP)
mean(Skewness.ONNO)
mean(Skewness.NYCH)
mean(Skewness.ONPG)
mean(Skewness.NJPT)

#Mean duration x population code
mean(Duration.ONEC)
mean(Duration.ONRO)
mean(Duration.NYSC)
mean(Duration.NYLV)
mean(Duration.ONDM)
mean(Duration.ONTI)
mean(Duration.MDDB)
mean(Duration.ONWH)
mean(Duration.NJHP)
mean(Duration.ONNO)
mean(Duration.NYCH)
mean(Duration.ONPG)
mean(Duration.NJPT)

#Mean start date x population code
mean(Start.date.ONEC)
mean(Start.date.ONRO)
mean(Start.date.NYSC)
mean(Start.date.NYLV)
mean(Start.date.ONDM)
mean(Start.date.ONTI)
mean(Start.date.MDDB)
mean(Start.date.ONWH)
mean(Start.date.NJHP)
mean(Start.date.ONNO)
mean(Start.date.NYCH)
mean(Start.date.ONPG)
mean(Start.date.NJPT)
```

```{r}
#Rho matrix
rho.matrix <- t(trait.matrix) %*% mating.matrix %*% trait.matrix #Z transpose*phi*Z 
pheno.matrix<- var(trait.matrix)
path.matrix<-  solve(pheno.matrix) %*% rho.matrix


#calculate variance in trait among all plants; var(); if positive, tend to mate similarly; if negative, tend to mate oppositely
#Let's say z is our vector of a trait -- each cell is an individual observation for a specific plant, so variance=sum(z-mean(z))
#var = sum((z-mean(z))^2)/(length(z)-1)
#used to compare with inflated variance upon assortative mating 
##Don't think we need anything after this point

#Find start date
##Method 1
Start.date<-names(Mating.Matrix.Data_Wide2)[max.col(Mating.Matrix.Data_Wide2 != 0, ties.method = "first")]
##Method 2
#Start date starting with 0
names(Mating.Matrix.Data_Wide2)[apply(Mating.Matrix.Data_Wide2 != 0, 1, which.max)]


#Select individuals to act as mothers
bootstrapped.index.M <- sample(index, N, replace=T)  
bootstrapped.sample.M <- Mating.Matrix.Data_Wide[bootstrapped.index.M,]
flr.matrix.M<-as.matrix(bootstrapped.sample.M[,11:36])
trait.matrix.raw.M<-as.matrix(bootstrapped.sample.M[,4:10])  
trait.matrix.std.M<- scale(trait.matrix.raw.M)	

#Select individuals to act as fathers
bootstrapped.index.F <- sample(index, N, replace=T)  
bootstrapped.sample.F <- Mating.Matrix.Data_Wide[bootstrapped.index.F,]
flr.matrix.F<-as.matrix(bootstrapped.sample.F[,11:36])
trait.matrix.raw.F<-as.matrix(bootstrapped.sample.F[,4:10])
trait.matrix.std.F<- scale(trait.matrix.raw.F)
father.colsum<- apply(flr.matrix.F, 2,  sum)
father.flr.matrix<- apply(flr.matrix.F, 1, function(d) d/father.colsum)


#Creates the between-mate correlation matrix ("R" matrix)
rho.matrix <- t(trait.matrix.std.M) %*% mating.matrix %*% trait.matrix.std.F
rho.output.row <- as.vector(rho.matrix)
output.table.rho2 <- rbind(output.table.rho2, rho.output.row)

ncol(trait.matrix.std.M) #7
nrow(trait.matrix.std.M) #1

ncol(mating.matrix) #386
nrow(mating.matrix) #386

ncol(trait.matrix.std.F) #7
nrow(trait.matrix.std.F) #1

scale(mating.matrix)
```